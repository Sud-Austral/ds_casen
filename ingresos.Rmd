---
title: |
  <br>
  <font size="14">
  Los ingresos totales de los chilenos desde el 2006 al 2017 </font>
author:
- name: VE-MS-CC
  affiliation: DataIntelligence
subtitle: |
  Compendio
date: "20-04-2021"
abstract: |

  En nuestro artículo https://rpubs.com/dataintelligence/la_construccion_de_los_ingresos_2, defendimos el analisis de 4 ingresos. En éste trabajo generamos la tabla que permitirá desplegar gráficas en Zoho. Hacemos un respaldo de las tablas en Postgres en Azure a la vez que vamos construyendo nuestra propia base de datos en ella.

header-includes:
   - \usepackage[]{babel}
output: 
  html_document:
      theme: flatly
---

```{r , message=FALSE, warning=FALSE, include = FALSE, echo = FALSE}
library(RPostgreSQL)
library(devtools)
library(remotes)
library(DBI)
library(tidyverse)
library(kableExtra)
library(reldist)
library("readxl")
```

## Índice{#invtest1}

**Éste programa corre con la version R-3.6.3**

### [1. Introducción ](#test1)

[(volver al índice)](#invtest1)

### 1. Introducción

<!-- falta hacer tabas de migra con ingresos(27-01-21) -->
<!-- generar tablas de variable que falta -->
<!-- graficas con vivienda -->



<hr style="height:1px;border-width:1;color:Gray;background-color:Gray">

<br>

### 2006

```{r}
dataset_2006 <- readRDS(file = "casen_2006_c.rds")
```

```{r}
ab <- dataset_2006
```

```{r}
# Eliminamos del dataframe los registros que no posean valores en la columna del ingreso total:
ab <- ab[!is.na(ab$YTOTAJ),]

# Excluimos los outliers
Q <- quantile(ab$YTOTAJ, probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(ab$YTOTAJ)
eliminated <- subset(ab, ab$YTOTAJ > (Q[1] - 1.5*iqr) & ab$YTOTAJ < (Q[2]+1.5*iqr))
eliminated <- data.frame(lapply(eliminated, as.character), stringsAsFactors=FALSE)

# despleguemos los primeros 100 registros en pantalla del subset creado:
# eliminated_100 <- eliminated[c(1:100),]
# eliminated_100 %>%  kbl() %>%
# kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")

# eliminated_100


```

```{r}
prueba <- unique(eliminated[c("COMUNA")])
pru
```



```{r}
#prueba <- unique(eliminated$COMUNA) %>% unique(eliminated$SEXO)

prueba <- unique(eliminated[c("COMUNA", "SEXO", "T4", "E1")])

prueba


```



20100

```{r, message=FALSE, warning=FALSE, results='hide'}
b <-  as.numeric(eliminated$YTOTAJ)
a <- eliminated$COMUNA
c <- eliminated$T4
d <- eliminated$E1
e <- eliminated$SEXO

# Calculamos los promedios de ingreso grupales, la desviación estandar del rango y el coeficiente de Gini:
promedios_grupales <-aggregate(b, by=list(a,c,d,e), FUN = mean , na.rm=TRUE )
promedios_grupales_sd <-aggregate(b, by=list(a,c,d,e), FUN = sd , na.rm=TRUE )
promedios_grupales_gini <-aggregate(b, by=list(a,c,d,e), FUN = gini  )

# Asignamos nuevas columnas a la tabla base con medias y sd:
promedios_grupales$sd <- promedios_grupales_sd$x
promedios_grupales$gini <- promedios_grupales_gini$x

# Eliminamos los valores que no tengan desviacion standard, pues implican registros unicos.
promedios_grupales <-promedios_grupales[!(is.na(promedios_grupales$sd)),]

# promedios_grupales_100 <- promedios_grupales[c(1:100),]

# promedios_grupales_100 %>%  kbl() %>% kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")

# promedios_grupales_100


```

```{r}
#Asignamos nombres con sentido a las cabeceras:
names(promedios_grupales)[1] <- "comuna"
names(promedios_grupales)[2] <- "Etnia"
names(promedios_grupales)[3] <- "Alfabetismo"
names(promedios_grupales)[4] <- "sexo"
names(promedios_grupales)[5] <- "promedio"
names(promedios_grupales)[6] <- "sd"
names(promedios_grupales)[7] <- "gini"
promedios_grupales$año <- "2006"
```

```{r}
codigos_comunales <- readRDS(file = "codigos_comunales_2006.rds")
names(codigos_comunales)[1] <- "código"
names(codigos_comunales)[2] <- "comuna"
```

```{r}
df_2006 = merge( x = promedios_grupales, y = codigos_comunales, by = "comuna", all.x = TRUE)
# head(df_2006,50) %>%  kbl() %>% kable_material(c("striped", "hover"), font_size = 12)%>%
# scroll_box(width = "100%", height = "500px")

head(df_2006,10)


```


```{r}
uno <-unique(df_2006$sexo)
uno
```
20100


335
10
3
2


### 2009

```{r}
dataset_2009 <- readRDS(file = "casen_2009_c.rds")
```

```{r}
ab <- dataset_2009
```

```{r}
# Eliminamos del dataframe los registros que no posean valores en la columna del ingreso total:
ab <- ab[!is.na(ab$YTOTAJ),]

# Excluimos los outliers
Q <- quantile(ab$YTOTAJ, probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(ab$YTOTAJ)
eliminated <- subset(ab, ab$YTOTAJ > (Q[1] - 1.5*iqr) & ab$YTOTAJ < (Q[2]+1.5*iqr))
eliminated <- data.frame(lapply(eliminated, as.character), stringsAsFactors=FALSE)

# despleguemos los primeros 100 registros en pantalla del subset creado:
eliminated_100 <- eliminated[c(1:100),]
# eliminated_100 %>%  kbl() %>%
# kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r, message=FALSE, warning=FALSE, results='hide'}
b <-  as.numeric(eliminated$YTOTAJ)
a <- eliminated$COMUNA
c <- eliminated$T5
d <- eliminated$E1
e <- eliminated$SEXO

# Calculamos los promedios de ingreso grupales, la desviación estandar del rango y el coeficiente de Gini:
promedios_grupales <-aggregate(b, by=list(a,c,d,e), FUN = mean , na.rm=TRUE )
promedios_grupales_sd <-aggregate(b, by=list(a,c,d,e), FUN = sd , na.rm=TRUE )
promedios_grupales_gini <-aggregate(b, by=list(a,c,d,e), FUN = gini  )

# Asignamos nuevas columnas a la tabla base con medias y sd:
promedios_grupales$sd <- promedios_grupales_sd$x
promedios_grupales$gini <- promedios_grupales_gini$x

# Eliminamos los valores que no tengan desviacion standard, pues implican registros unicos.
promedios_grupales <-promedios_grupales[!(is.na(promedios_grupales$sd)),]

promedios_grupales_100 <- promedios_grupales[c(1:100),]

# 
# 
# promedios_grupales_100 %>%  kbl() %>% kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r}
#Asignamos nombres con sentido a las cabeceras:
names(promedios_grupales)[1] <- "comuna"
names(promedios_grupales)[2] <- "Etnia"
names(promedios_grupales)[3] <- "Alfabetismo"
names(promedios_grupales)[4] <- "sexo"
names(promedios_grupales)[5] <- "promedio"
names(promedios_grupales)[6] <- "sd"
names(promedios_grupales)[7] <- "gini"
promedios_grupales$año <- "2009"
```

```{r}
codigos_comunales <- readRDS(file = "codigos_comunales_2009.rds")
names(codigos_comunales)[1] <- "código"
names(codigos_comunales)[2] <- "comuna"
```

```{r}
df_2009 = merge( x = promedios_grupales, y = codigos_comunales, by = "comuna", all.x = TRUE)
head(df_2009,10)
```




### 2011

```{r}
dataset_2011 <- readRDS(file = "casen_2011_c.rds")
```

```{r}
ab <- dataset_2011
```

```{r}
# Eliminamos del dataframe los registros que no posean valores en la columna del ingreso total:
ab <- ab[!is.na(ab$ytotaj),]

```

```{r}
# Excluimos los outliers
Q <- quantile(ab$ytotaj, probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(ab$ytotaj)
eliminated <- subset(ab, ab$ytotaj > (Q[1] - 1.5*iqr) & ab$ytotaj < (Q[2]+1.5*iqr))
eliminated <- data.frame(lapply(eliminated, as.character), stringsAsFactors=FALSE)

# despleguemos los primeros 100 registros en pantalla del subset creado:
eliminated_100 <- eliminated[c(1:100),]
# eliminated_100 %>%  kbl() %>%
# kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r, message=FALSE, warning=FALSE, results='hide'}
b <-  as.numeric(eliminated$ytotaj)
a <- eliminated$comuna
c <- eliminated$r6
d <- eliminated$e1
e <- eliminated$sexo

# Calculamos los promedios de ingreso grupales, la desviación estandar del rango y el coeficiente de Gini:
promedios_grupales <-aggregate(b, by=list(a,c,d,e), FUN = mean , na.rm=TRUE )
promedios_grupales_sd <-aggregate(b, by=list(a,c,d,e), FUN = sd , na.rm=TRUE )
promedios_grupales_gini <-aggregate(b, by=list(a,c,d,e), FUN = gini  )

# Asignamos nuevas columnas a la tabla base con medias y sd:
promedios_grupales$sd <- promedios_grupales_sd$x
promedios_grupales$gini <- promedios_grupales_gini$x

# Eliminamos los valores que no tengan desviacion standard, pues implican registros unicos.
promedios_grupales <-promedios_grupales[!(is.na(promedios_grupales$sd)),]

promedios_grupales_100 <- promedios_grupales[c(1:100),]

# promedios_grupales_100 %>%  kbl() %>% kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r}
#Asignamos nombres con sentido a las cabeceras:
names(promedios_grupales)[1] <- "comuna"
names(promedios_grupales)[2] <- "Etnia"
names(promedios_grupales)[3] <- "Alfabetismo"
names(promedios_grupales)[4] <- "sexo"
names(promedios_grupales)[5] <- "promedio"
names(promedios_grupales)[6] <- "sd"
names(promedios_grupales)[7] <- "gini"
promedios_grupales$año <- "2011"
```

```{r}
codigos_comunales <- readRDS(file = "codigos_comunales_2011-2017.rds")
names(codigos_comunales)[1] <- "código"
names(codigos_comunales)[2] <- "comuna"
```

```{r}
df_2011 = merge( x = promedios_grupales, y = codigos_comunales, by = "comuna", all.x = TRUE)

head(df_2011,10)
```



### 2013

```{r}
dataset_2013 <- readRDS(file = "casen_2013_c.rds")
```

```{r}
ab <- dataset_2013
```

```{r}
# Eliminamos del dataframe los registros que no posean valores en la columna del ingreso total:
ab <- ab[!is.na(ab$ytotcor),]

```

```{r}
# Excluimos los outliers
Q <- quantile(ab$ytotcor, probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(ab$ytotcor)
eliminated <- subset(ab, ab$ytotcor > (Q[1] - 1.5*iqr) & ab$ytotcor < (Q[2]+1.5*iqr))
eliminated <- data.frame(lapply(eliminated, as.character), stringsAsFactors=FALSE)

# despleguemos los primeros 100 registros en pantalla del subset creado:
eliminated_100 <- eliminated[c(1:100),]
# eliminated_100 %>%  kbl() %>%
# kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r, message=FALSE, warning=FALSE, results='hide'}
b <-  as.numeric(eliminated$ytotcor)
a <- eliminated$comuna
c <- eliminated$r6
d <- eliminated$e1
e <- eliminated$sexo

# Calculamos los promedios de ingreso grupales, la desviación estandar del rango y el coeficiente de Gini:
promedios_grupales <-aggregate(b, by=list(a,c,d,e), FUN = mean , na.rm=TRUE )
promedios_grupales_sd <-aggregate(b, by=list(a,c,d,e), FUN = sd , na.rm=TRUE )
promedios_grupales_gini <-aggregate(b, by=list(a,c,d,e), FUN = gini  )

# Asignamos nuevas columnas a la tabla base con medias y sd:
promedios_grupales$sd <- promedios_grupales_sd$x
promedios_grupales$gini <- promedios_grupales_gini$x

# Eliminamos los valores que no tengan desviacion standard, pues implican registros unicos.
promedios_grupales <-promedios_grupales[!(is.na(promedios_grupales$sd)),]

promedios_grupales_100 <- promedios_grupales[c(1:100),]



# promedios_grupales_100 %>%  kbl() %>% kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r}
#Asignamos nombres con sentido a las cabeceras:
names(promedios_grupales)[1] <- "comuna"
names(promedios_grupales)[2] <- "Etnia"
names(promedios_grupales)[3] <- "Alfabetismo"
names(promedios_grupales)[4] <- "sexo"
names(promedios_grupales)[5] <- "promedio"
names(promedios_grupales)[6] <- "sd"
names(promedios_grupales)[7] <- "gini"
promedios_grupales$año <- "2013"
```

```{r}
codigos_comunales <- readRDS(file = "codigos_comunales_2011-2017.rds")
names(codigos_comunales)[1] <- "código"
names(codigos_comunales)[2] <- "comuna"
```

```{r}
df_2013 = merge( x = promedios_grupales, y = codigos_comunales, by = "comuna", all.x = TRUE)

head(df_2013,10)
```




### 2015

```{r}
dataset_2015 <- readRDS(file = "casen_2015_c.rds")
```

```{r}
ab <- dataset_2015
```

```{r}
# Eliminamos del dataframe los registros que no posean valores en la columna del ingreso total:
ab <- ab[!is.na(ab$ytotcor),]

```

```{r}
# Excluimos los outliers
Q <- quantile(ab$ytotcor, probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(ab$ytotcor)
eliminated <- subset(ab, ab$ytotcor > (Q[1] - 1.5*iqr) & ab$ytotcor < (Q[2]+1.5*iqr))
eliminated <- data.frame(lapply(eliminated, as.character), stringsAsFactors=FALSE)

# despleguemos los primeros 100 registros en pantalla del subset creado:
eliminated_100 <- eliminated[c(1:100),]
# eliminated_100 %>%  kbl() %>%
# kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r, message=FALSE, warning=FALSE, results='hide'}
b <-  as.numeric(eliminated$ytotcor)
a <- eliminated$comuna
c <- eliminated$r3
d <- eliminated$e1
e <- eliminated$sexo

# Calculamos los promedios de ingreso grupales, la desviación estandar del rango y el coeficiente de Gini:
promedios_grupales <-aggregate(b, by=list(a,c,d,e), FUN = mean , na.rm=TRUE )
promedios_grupales_sd <-aggregate(b, by=list(a,c,d,e), FUN = sd , na.rm=TRUE )
promedios_grupales_gini <-aggregate(b, by=list(a,c,d,e), FUN = gini  )

# Asignamos nuevas columnas a la tabla base con medias y sd:
promedios_grupales$sd <- promedios_grupales_sd$x
promedios_grupales$gini <- promedios_grupales_gini$x

# Eliminamos los valores que no tengan desviacion standard, pues implican registros unicos.
promedios_grupales <-promedios_grupales[!(is.na(promedios_grupales$sd)),]

promedios_grupales_100 <- promedios_grupales[c(1:100),]

# promedios_grupales_100 %>%  kbl() %>% kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r}
#Asignamos nombres con sentido a las cabeceras:
names(promedios_grupales)[1] <- "comuna"
names(promedios_grupales)[2] <- "Etnia"
names(promedios_grupales)[3] <- "Alfabetismo"
names(promedios_grupales)[4] <- "sexo"
names(promedios_grupales)[5] <- "promedio"
names(promedios_grupales)[6] <- "sd"
names(promedios_grupales)[7] <- "gini"
promedios_grupales$año <- "2015"
```

```{r}
codigos_comunales <- readRDS(file = "codigos_comunales_2011-2017.rds")
names(codigos_comunales)[1] <- "código"
names(codigos_comunales)[2] <- "comuna"
```

```{r}
df_2015 = merge( x = promedios_grupales, y = codigos_comunales, by = "comuna", all.x = TRUE)

head(df_2015,10)
```




### 2017

```{r}
dataset_2017 <- readRDS(file = "casen_2017_c.rds")
```

```{r}
ab <- dataset_2017
```

```{r}
# Eliminamos del dataframe los registros que no posean valores en la columna del ingreso total:
ab <- ab[!is.na(ab$ytotcor),]

```

```{r}
# Excluimos los outliers
Q <- quantile(ab$ytotcor, probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(ab$ytotcor)
eliminated <- subset(ab, ab$ytotcor > (Q[1] - 1.5*iqr) & ab$ytotcor < (Q[2]+1.5*iqr))
eliminated <- data.frame(lapply(eliminated, as.character), stringsAsFactors=FALSE)

# despleguemos los primeros 100 registros en pantalla del subset creado:
eliminated_100 <- eliminated[c(1:100),]
# eliminated_100 %>%  kbl() %>%
# kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r, message=FALSE, warning=FALSE, results='hide'}
b <-  as.numeric(eliminated$ytotcor)
a <- eliminated$comuna
c <- eliminated$r3
d <- eliminated$e1
e <- eliminated$sexo

# Calculamos los promedios de ingreso grupales, la desviación estandar del rango y el coeficiente de Gini:
promedios_grupales <-aggregate(b, by=list(a,c,d,e), FUN = mean , na.rm=TRUE )
promedios_grupales_sd <-aggregate(b, by=list(a,c,d,e), FUN = sd , na.rm=TRUE )
promedios_grupales_gini <-aggregate(b, by=list(a,c,d,e), FUN = gini  )

# Asignamos nuevas columnas a la tabla base con medias y sd:
promedios_grupales$sd <- promedios_grupales_sd$x
promedios_grupales$gini <- promedios_grupales_gini$x

# Eliminamos los valores que no tengan desviacion standard, pues implican registros unicos.
promedios_grupales <-promedios_grupales[!(is.na(promedios_grupales$sd)),]

# promedios_grupales %>%  kbl() %>% kable_material(c("striped", "hover"), font_size = 12)%>%
#    scroll_box(width = "100%", height = "500px")
```

```{r}
#Asignamos nombres con sentido a las cabeceras:
names(promedios_grupales)[1] <- "comuna"
names(promedios_grupales)[2] <- "Etnia"
names(promedios_grupales)[3] <- "Alfabetismo"
names(promedios_grupales)[4] <- "sexo"
names(promedios_grupales)[5] <- "promedio"
names(promedios_grupales)[6] <- "sd"
names(promedios_grupales)[7] <- "gini"
promedios_grupales$año <- "2017"
```

```{r}
codigos_comunales <- readRDS(file = "codigos_comunales_2011-2017.rds")
names(codigos_comunales)[1] <- "código"
names(codigos_comunales)[2] <- "comuna"
```

```{r}
df_2017 = merge( x = promedios_grupales, y = codigos_comunales, by = "comuna", all.x = TRUE)

head(df_2017,10)
```



```{r}
ytotcor_ytotaj <- rbind(df_2006,df_2009,df_2011,df_2013,df_2015,df_2017)
head(ytotcor_ytotaj,10)
nrow(ytotcor_ytotaj)
```

20100*6 = 120600




### Vamos a homologar las categorias de etnia y alfabetismo

```{r}
alfabetismo <- read_xlsx("alfabetismo_unicos.xlsx")
categorias <- read_xlsx("categorias_etnia.xlsx")

nuevas_cat = merge( x = ytotcor_ytotaj, y = alfabetismo, by = "Alfabetismo", all.x = TRUE)

# nuevas_cat


```


```{r}
alfa_corr <- nuevas_cat[,c(-1)]
# alfa_corr
```


```{r}
categoriasbuenas = merge( x = alfa_corr, y = categorias, by = "Etnia", all.x = TRUE)
# categoriasbuenas
```


```{r}
etnia_corr <- categoriasbuenas[,c(-1)]
# etnia_corr
```


```{r}
names(etnia_corr)[8] <- "alfabetismo"
names(etnia_corr)[9] <- "etnia"
receptaculo <- etnia_corr[,c(1,2,8,9,3,4,5,6,7)]

head(receptaculo, 10)
nrow(receptaculo)
```
```{r}
saveRDS(receptaculo,"receptaculo.rds")
```



```{r}
rec <- filter(receptaculo, receptaculo$comuna == "Iquique" & receptaculo$sexo == "Hombre" & receptaculo$etnia == "Aymara" & receptaculo$alfabetismo == "Sí")
rec
```

```{r}
rec$año <- as.double(rec$año)
rec
```

```{r}
library(ggplot2)
# Basic line plot with points
ggplot(data=rec, aes(x=año, y=promedio, group=1)) +
  geom_line()+
  geom_point()
```






```{r}
# write_excel_csv2(receptaculo, "ingresos.csv")
```




Apendice: trabajo sobre la base de datos Postgres

```{r echo = FALSE}
# db <- 'trabajo-con-casen'  #provide the name of your db
# host_db <- 'post-to-r.postgres.database.azure.com' #i.e. # i.e. 'ec2-54-83-201-96.compute-1.amazonaws.com'
# db_port <- '5432'  # or any other port specified by the DBA
# db_user <- 'yomismo@post-to-r'
# db_password <- '123456Fg*'
# con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
```

```{r}
# library('RPostgreSQL')
# tn <- 'promedios_grupales_x'
# dbRemoveTable(con,tn)
```
#
#
```{r}
# library('RPostgreSQL')
# # tn <- 'links'
# dbWriteTable(con,'promedios_grupales_x',promedios_grupales_x, row.names=FALSE)
```
#
```{r}
# dbGetQuery(con, 'SELECT * FROM promedios_grupales_x ')
```
#
#
```{r}
#
# dbGetQuery(con, "SELECT * FROM promedios_grupales_x WHERE comuna = 'Antofagasta' ")
```



<!-- ```{r} -->
<!-- dbGetQuery(con, 'SELECT * FROM promedios_grupales')  -->
<!-- ``` -->















